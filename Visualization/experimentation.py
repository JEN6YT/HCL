import numpy as np

class Experiment():
    def compute_filters_AtBt(self, w, model_target_users): 
        
        # compute filters for At and Bt sets in our documentation 
        # https://docs.google.com/document/d/1c8uCtvh71_Px1PS4NfdF0qDpA-8rZ10GtFYUaGkc6F4/edit 
        # these are sets where 
        #   At: a user is 'selected/targeted' and 'treated' 
        #   Bt: a user is 'selected/targeted' and 'not-treated' 
        # 
        # w: treatment label 
        # model_target_users: the binary vector indicating whether each user is targeted 
        
        target_treated_users = np.logical_and((w > 0.5), (model_target_users > 0.5)) 
        target_nontreated_users = np.logical_and((w <= 0.5), (model_target_users > 0.5)) 
        return target_treated_users, target_nontreated_users 

    def compute_increment_orders_target(self, values, w, model_target_users, n9d_ni_usd): 
            
        ## compute incremental orders and incremental cost series 
        ## then plot them to construct a cost curve for selection/targeting 
        ## model evaluation 
        ## values: the value representation or # of orders 
        ## w: the treatment labels 
        ## model_target_users: binary vector indicating whether the user is targeted per dimension 
        ## n9d_ni_usd: the next 9 days inflow numbers for evaluation of incremental cost 
        
        target_treated_users, target_nontreated_users = self.compute_filters_AtBt(w, model_target_users) 
        
        num_users = np.sum(model_target_users) 
        
        values_At = values[target_treated_users] 
        values_Bt = values[target_nontreated_users] 
        
        #values_At = np.minimum(values_At, 20.0) 
        #values_Bt = np.minimum(values_Bt, 20.0) 
        
        nis_At = n9d_ni_usd[target_treated_users] 
        nis_Bt = n9d_ni_usd[target_nontreated_users] 
        
        try: 
            a = 1.0 * np.sum(values_At) 
            b = 1.0 * np.sum(values_Bt) 
            io = a - b 
            
            c = 1.0 * np.sum(nis_At) 
            d = 1.0 * np.sum(nis_Bt) 
            
            # incremental cost: negative of difference in net-inflow 
            ic = -1.0 * ( c - d ) 
            
            # handle divide by zeros 
            a = a / len(values_At) 
            b = b / len(values_Bt) 
            c = c / len(nis_At) 
            d = d / len(nis_Bt) 
            
            ## incremental order per user and its percentage version 
            oput = a 
            opun = b 
            cput = c 
            cpun = d 
            iopu =  a - b 
            icpu =  -1.0 * ( c - d ) 
            
            #num_treated = len(values_At) 
            treatment_ratio = 1.0 * len(values_At) / (len(values_At) + len(values_Bt)) 
            
            num_treated = len(values_At) 
            
            io = iopu * num_treated 
            ic = icpu * num_treated
            
            #io = oput * num_users * treatment_ratio - opun * num_users * (1.0 - treatment_ratio) 
            
            #io = 0.5 * num_users * iopu  
            #ic = 0.5 * num_users * icpu 
        except: 
            io = 0 
            ic = 0 
            iopu = 0 
            icpu = 0 
            treatment_ratio = 0.0 
        
        return io, ic, iopu, icpu, num_users, treatment_ratio

    def AUC_ivpu(self, pred_values, values, w, thresh_list, color, n9d_ni_usd, plot=False):
        ## function plots ivpu versus population percentage 
        ## and [TODO] to compute Area Under Curve (AUC) 
        ##   pred_values: list of model predictions, same vertical dim as # data points 
        ##   values: actual labels (reward or value) 
        ##   w: treatment labels {1,0} 
        ##   thresh_list: a range of thresholds generated by numpy.arange based on histogram of pred_values 
        
        percs = [] 
        iopus = [] 
        icpus = [] 
        for t in thresh_list: 
            model_target_users = pred_values > t 
            try: # handle divide by zero 
                perc_users = 1.0 * np.sum(model_target_users) / len(model_target_users) 
            except: 
                perc_users = 0.0 
            d1, d2, iopu, icpu, num_users, treatment_ratio = self.compute_increment_orders_target(values, w, model_target_users, n9d_ni_usd) 
            percs.append(perc_users) 
            iopus.append(iopu) 
            icpus.append(icpu)
        
        # if plot:
        #     ## plotting
        #     plt.plot(percs, iopus, '-o'+color, markersize=12, linewidth=3)
        #     plt.xlabel('% population covered')
        #     plt.ylabel('Incremental # of orders per user')
        #     #plt.ylim([0, 0.3])
        #     plt.grid(True)
        
        return percs, iopus, icpus
